import argparse
import Bio 
from Bio import Entrez  #The way to access the RefSeq database programmatically 
from Bio import SeqIO 
from Bio.PDB import PDBList, PDBParser
from Bio.SeqUtils import seq1, seq3 
import numpy
from pathlib import Path
import pickle
import time 
from unipressed import IdMappingClient

parser = argparse.ArgumentParser(prog='codon_rarity', description='Replaces the b-factor entries in a .pdb file with the codon rarity based upon species.')
parser.add_argument('-f', '--filename', type=str, help='pdb file to annotate') #Disabling for now since I want to do automatic database searching
parser.add_argument('-nuc', '--nucseq',  type=str, help='A manually entered nucleic acid sequence to split into codons ') 
parser.add_argument('-acc', '--accessionID', type=str, help='The accession ID of the gene/protein being fetched')
parser.add_argument('-pdb', '--PDBID', type=str, help='RSCB Protein Data Bank ID to fetch .pdb file')
parser.add_argument('-tax', '--taxID',  type=str, help='TaxID to load the relevant codon rarity table', required=True)
parser.add_argument('-ct', '--codontables',  type=str, help=f'Pickle file (usually .pkl) of the codon tables, organised by taxID', default='codon_tables.pkl')
parser.add_argument('-o', '--outfile', type=str, help='name out annotate .pdb output file')
args = parser.parse_args()

def filenames_from_args(PDBID, filename, outfile): 
    pdbfile = ''
    if (PDBID is not None):
        PDBList().retrieve_pdb_file(PDBID, file_format='pdb', pdir='.', overwrite=True, obsolete=False) 
        pdbfile = Path('pdb{}.ent' .format((PDBID)).lower())
        pdbfile = pdbfile.rename('{}.pdb' .format((PDBID)).lower())
        Path('obsolete').rmdir() #Generated by PDB API, unneeded, should be empty
    
    if (filename is not None): 
       pdbfile = Path(filename)

    if (args.outfile is None):
        outfile = Path(f'codon_annot_{pdbfile}') #if not specified, just give pre-pend that it's annotated 
    else:
        outfile = Path(args.outfile)

    return pdbfile, outfile

def load_codon_table(codon_tables, taxID):  #I can probably have the codon table inbuilt
    with open(codon_tables, 'rb') as pickle_file:
        codon_tables = pickle.load(pickle_file)
    return codon_tables[taxID]

def map_IDs_UniProt(PDBID):
    print('PDBID is: {}' .format(PDBID))

    UniProtKB_req = IdMappingClient.submit(source='PDB', dest='UniProtKB', ids={PDBID}) #one of the few formats you can convert to from PDB
    time.sleep(1)
    UniProtKBs_result = list(UniProtKB_req.each_result())
    UniProtKB_ID = UniProtKBs_result[0]['to'] #TO DO: This is just taking the first hit, think about if this is always appropriate  
    print('UniProtKB is: {}' .format(UniProtKB_ID))

    RefSeq_nuc_req = IdMappingClient.submit(source='UniProtKB_AC-ID', dest='RefSeq_Nucleotide', ids={UniProtKB_ID}) #weirdly now it *must* be AC-ID.
    time.sleep(1)
    RefSeq_nucs_result = list(RefSeq_nuc_req.each_result())
    RefSeq_nuc_ID = RefSeq_nucs_result[0]['to'] 
    print('RefSeq_nuc_ID is: {}' .format(RefSeq_nuc_ID))
    return UniProtKB_ID, RefSeq_nuc_ID

def pdbfile2struct(pdbfile): # TO DO: consider file -> pdbfile variable rename. Can Bio.PDB help here with reading (PDBIO.select pulling out 'REMARK', etc)
    parser = PDBParser()
    struct_name = str(pdbfile).replace('.pdb', '')
    pdb_struct = parser.get_structure(struct_name, pdbfile)
    return pdb_struct

#def validate_pdb_residues(pdb_struc): # Want to things like "HOH", non standard amino acids not in place. Use BioPython PDB alphabet or PDB.PDBIO.Select select_residue() https://biopython.org/docs/1.76/api/Bio.PDB.PDBIO.html

def fetch_nucseq(RefSeq_nuc_ID): #Get the FASTA file of the sequence from RefSeq_Nucleotide ID
    Entrez.email = "k.rowell@unsw.edu.au" #TO DO: remove/update once there are other users of the code 
    RefSeq_handle = Entrez.efetch(db='nucleotide', id=RefSeq_nuc_ID, rettype='fasta', retmode='text') 
    RefSeq_record = SeqIO.read(RefSeq_handle, 'fasta')
    RefSeq_nuc_seq = str(RefSeq_record.seq)
    RefSeq_handle.close()
    return RefSeq_nuc_seq
    
def nucseq2codons(pdb_struct, nucseq):
    codons = [nucseq[i:i+3] for i in range(0, len(nucseq), 3)] 
    return codons


def replace_b_factor(pdb_struct, codons, codon_table): 
    a_idx = 0  # no neat way to link idx to enumerate
    res_idx = 0
    for model in pdb_struct: #doesn't hurt, but check later if there are pdbs with multiple models
        for chain in model:
            for residue in chain:
                res_idx += 1
                res_3let = residue.get_resname()
                res_1let = seq1(res_3let)
                for atom in residue:
                    codon_rarity_val = codon_table[res_1let][codons[res_idx-1]]
                    atom.set_bfactor(codon_rarity_val) #this is used in AlphaFold to colour residue position certainty

pdbfile, outfile = filenames_from_args(args.PDBID, args.filename, args.outfile)
codon_table = load_codon_table(args.codontables, args.taxID)
print(f'Codon fraction table for {args.taxID} is {codon_table}')
UniProtKD_ID, RefSeq_nuc_ID = map_IDs_UniProt(args.PDBID)
pdb_struct = pdbfile2struct(pdbfile)
#validate_pdb_residues()

#### from here testing if residue match codons..
pdb_residues = []  
for residue in pdb_struct.get_residues():
    pdb_residues.append(residue.get_resname())
print(f'The residue sequence in the protein is: {pdb_residues}')
#### 
if args.nucseq is not None: #Need to decide which overrides
    seq_record = SeqIO.read(args.nucseq, 'fasta') 
    nucseq = str(seq_record.seq)
if RefSeq_nuc_ID is not None:
    nucseq = fetch_nucseq(RefSeq_nuc_ID)
    print(f'The nucleic acid sequence from RefSeq is: {nucseq}')
codons = nucseq2codons(pdb_struct, nucseq)
3replace_b_factor(pdb_struct, codons, codon_table)  
