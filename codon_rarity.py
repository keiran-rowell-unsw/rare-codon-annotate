import argparse
import Bio 
from Bio import Entrez  #The way to access the RefSeq database programmatically 
from Bio import SeqIO 
from Bio.PDB import PDBList
from pathlib import Path
import python_codon_tables as pct 
import time 
from unipressed import IdMappingClient



# Use in a shellscript with -f or -p, rather than have positional args or ability to supply a list of files/PDBIDs 
parser = argparse.ArgumentParser(prog='codon_rarity', description='Replaces the b-factor entries in a .pdb file with the codon rarity based upon species.')
#group = parser.add_mutually_exclusive_group() #only one of -f or -p 
parser.add_argument('-f', '--filename', type=str, help='pdb file to annotate') #Disabling for now since I want to do automatic database searching
#parser.add_argument('-m', '--mRNA',  type=str, help=' ') #Fill fetch this automaticallly, but also let this overwrite. There's a clinvar database in uniprot
# Determine here which database to fetch from 
parser.add_argument('-db', '--database', type=str, help='The database to query structure files from', choices=['EBI', 'PDB']) #consider -db_nuc and -db_prot
parser.add_argument('-a', '--accessionID', type=str, help='The accession ID of the gene/protein being fetched')
parser.add_argument('-p', '--PDBID', type=str, help='RSCB Protein Data Bank ID to fetch .pdb file')
parser.add_argument('-t', '--taxID',  type=str, help=f'Either TaxID, or species database from {pct.available_codon_tables_names}') #TO DO: move away  from pct and use codontablesdb w/ taxID
#parser.add_argument('-c', '--codon', type=str, help='the mutated codon that determines pathogenicity, give codon and location ') #Give the rarity difference number
#like4like codons can be called with the -l flag
#parser.add_argument('-l', '--like4like', type=str, help='Print a new codon_table that matches codon frequencies between species') 
parser.add_argument('-o', '--outfile', type=str, help='name out annotate .pdb output file')
args = parser.parse_args()

if (args.filename is not None): 
    file = Path(args.filename)

if (args.PDBID is not None):
    PDBList().retrieve_pdb_file(args.PDBID, file_format='pdb', pdir='.', overwrite=True, obsolete=False) 
    file = Path('pdb{}.ent' .format((args.PDBID)).lower())
    file = file.rename('{}.pdb' .format((args.PDBID)).lower())
    Path('obsolete').rmdir() #Generated by PDB API, unneeded, should be empty

#if (args.mRNA is None): #fetch automatically from PDB 
#    pass

if (args.outfile is None):
    outfile = Path(f'codon_annot_{file}') #if not specified, just give pre-pend that it's annotated 
else:
    outfile = Path(args.outfile)


def convert_structure_IDs(struct_ID): #To switch between EBI, PDB, accession, etc, (using IdMappingClien). Do I want to fetch in this as well? 
    pass 
    # return struct_ID

def fetch_structure_from_database(struct_ID, args.database): # To do the fetching from EBI, PDB etc. The format of the pdb file changes based on db 
    pass  

def read_pdb_contents(file, args.database): # TO DO: consider file -> pdbfile variable rename. Can Bio.PDB help here with reading (PDBIO.select pulling out 'REMARK', etc)
    #pdb_contents = file.read_text()
    #contents_w_condon_rarity = replace_b_factor(pdb_contents)
    pass 


#def like4like_codons(condon_table_species1, condon_table_species2):  #TO DO: incoporate like4like_codons.py into this function
#    return (like_for_like_codon_list)

#def replace_b_factor(pdb_contents, args.database):
    #write this replacement logic
    # should this value be diff between rarity in wt and current. Or just rare?
#    print(codon_table)
#    new_pdb_contents += repr(codon_table) #placeholder for now  
#    outfile.open('w').write(contents_w_condon_rarity)  #need to make outfile_contents. TO DO: do I want replace_b_factor to write out. I think I just want it to return the replaced b-factor lines 
#    return new_pdb_contents

PDB_record = SeqIO.read(file, 'pdb-seqres') #fails on multimers b.c. multiple seqres entries # TO DO: put this reading and conversion logic in the functions above  
PDB_res_seq = str(PDB_record.seq)

#Use the UniProt number to link the PDBID to the RNA database, the gene will known
print('PDBID is: {}' .format(args.PDBID))
UniProtKB_req = IdMappingClient.submit(source='PDB', dest='UniProtKB', ids={args.PDBID}) #one of the few formats you can convert to from PDB
time.sleep(1)
UniProtKBs_result = list(UniProtKB_req.each_result())
UniProtKB_ID = UniProtKBs_result[0]['to'] #TO DO: This is just taking the first hit, think about if this is always appropriate  
print('UniProtKB is: {}' .format(UniProtKB_ID))

RefSeq_nuc_req = IdMappingClient.submit(source='UniProtKB_AC-ID', dest='RefSeq_Nucleotide', ids={UniProtKB_ID}) #weirdly now it *must* be AC-ID.
time.sleep(1)
RefSeq_nucs_result = list(RefSeq_nuc_req.each_result())
RefSeq_nuc_ID = RefSeq_nucs_result[0]['to'] 
print('RefSeq_nuc is: {}' .format(RefSeq_nuc_ID))

#Get the FASTA file of the sequence from RefSeq_Nucleotide ID
Entrez.email = "k.rowell@unsw.edu.au" #TO DO: remove/update once there are other users of the code 
RefSeq_handle = Entrez.efetch(db='nucleotide', id=RefSeq_nuc_ID, rettype='fasta', retmode='text') 
RefSeq_record = SeqIO.read(RefSeq_handle, 'fasta')
RefSeq_nuc_seq = str(RefSeq_record.seq)
RefSeq_handle.close()


residues = []   #TO DO: could probably optimiser with a list comprehension, but getting started for now
codons = []
#Need to zip AA and codons together
for i, residue in enumerate(PDB_res_seq):
    residues.append(residue) #could just turn a str into a list, but this is how I view it conceptually
    codon = str(RefSeq_nuc_seq[i:i+3])
    codons.append(codon)

print(PDB_record.seq)
print(RefSeq_record.seq) 
codon_table = pct.get_codons_table(args.taxID)
print(codon_table)
for residue, codon in  zip(residues, codons):
    print(residue, codon)    
    rarity = codon_table[residue][codon]
    print(rarity)    
#rarity = codon_table[codon] #codon tables in DNA so no need to call seq.transcribe()
        #print(rarity) 
#From RNA sequence, look up codon_rarity table then replace the b-factor

